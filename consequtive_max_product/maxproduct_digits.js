//Attempt-1 failed to take consequtive numbers
// const inputNumber = 606382144605967;
// // const inputNumber = 90698244605967;

// function maxProductOfConsequtiveNum(num, n) {
//   let temp = 0;
//   let modifiedInput = num.toString().split("");
//   let newArray = []
//   let maxProduct = 0

//   for (let i = 0; i < modifiedInput.length; i++) {
//     for (let j = i; j < modifiedInput.length; j++) {
//       if (modifiedInput[i] < modifiedInput[j]) {
//         temp = modifiedInput[i];
//         modifiedInput[i] = modifiedInput[j];
//         modifiedInput[j] = temp;
//       }
//     }
//   }
//   for(let i = 0; i < n ; i++){
//     newArray.push(modifiedInput[i])
//   }
//   console.log(newArray)
//   maxProduct = newArray.reduce((num1, num2) => num1*num2, 1)
//   return maxProduct
// }

// console.log(maxProductOfConsequtiveNum(inputNumber, 12));

//Attempt - 2

function maxProductOfConsequtiveNum(num, n) {
  let modifiedInput = num.toString().split("");
  let product = 0;
  let maxProduct = 0;
  let newArray = [];
  let resultantConsequtiveNumbers = [];
  for (let i = 0; i <= modifiedInput.length - n; i++) {
    for (let j = 0; j < n; j++) {
      newArray.push(modifiedInput[j + i]);
    }
    product = newArray.reduce((acc, num) => acc * num, 1);
    if (product > maxProduct) {
      maxProduct = product;
      resultantConsequtiveNumbers = newArray;
    }

    newArray = [];
  }

  return [maxProduct, resultantConsequtiveNumbers];
}

const testCases = [
  {
    inputNumber:
      606382144605640950672689032181572171313581824917343183723916568388369607989004447272140509624916579535706201660821833878993452115326869600104717683283796374999873972204175291505595061135570231131894631236908643517527547090172932242250013548962810421162338803865035300115560942112050014905477757607209725901873457406572447356834020239827334007485819050503774398095554106482728330470053324830275963371217024611516145703393865095211734066415516710160419460587885646840794053001012174991751906549899233670267772116320101323662838542340516781500823503961368557142698692106930623983237728723386730781442737727268991789285059917963318350618581459707286531987665695457940053476204891430379503949735876958565238627494989132113001736831343237351779148277768594159478823592060643983228936471908895372067909804901159038293027624059766288233493140003048312017279450111560323399122036340719985189426861458985318125858070792969697727790157761659977131788182647728879601884097625785146912675660433142089480689389905n,
    n: 2,
    outPut: [81, [9, 9]],
  },
  {
    inputNumber:
      606382144605640950672689032181572171313581824917343183723916568388369607989004447272140509624916579535706201660821833878993452115326869600104717683283796374999873972204175291505595061135570231131894631236908643517527547090172932242250013548962810421162338803865035300115560942112050014905477757607209725901873457406572447356834020239827334007485819050503774398095554106482728330470053324830275963371217024611516145703393865095211734066415516710160419460587885646840794053001012174991751906549899233670267772116320101323662838542340516781500823503961368557142698692106930623983237728723386730781442737727268991789285059917963318350618581459707286531987665695457940053476204891430379503949735876958565238627494989132113001736831343237351779148277768594159478823592060643983228936471908895372067909804901159038293027624059766288233493140003048312017279450111560323399122036340719985189426861458985318125858070792969697727790157761659977131788182647728879601884097625785146912675660433142089480689389905n,
    n: 12,
    outPut: 4999796928,
  },
  {
    inputNumber:
      606382144605640950672689032181572171313581824917343183723916568388369607989004447272140509624916579535706201660821833878993452115326869600104717683283796374999873972204175291505595061135570231131894631236908643517527547090172932242250013548962810421162338803865035300115560942112050014905477757607209725901873457406572447356834020239827334007485819050503774398095554106482728330470053324830275963371217024611516145703393865095211734066415516710160419460587885646840794053001012174991751906549899233670267772116320101323662838542340516781500823503961368557142698692106930623983237728723386730781442737727268991789285059917963318350618581459707286531987665695457940053476204891430379503949735876958565238627494989132113001736831343237351779148277768594159478823592060643983228936471908895372067909804901159038293027624059766288233493140003048312017279450111560323399122036340719985189426861458985318125858070792969697727790157761659977131788182647728879601884097625785146912675660433142089480689389905n,
    n: 4,
    outPut: 5832,
  },
  {
    inputNumber: 6063821446056409506726890323232321n,
    n: 2,
    outPut: 72,
  },
  {
    inputNumber: 6063821446056409506726890321n,
    n: 4,
    outPut: 864,
  },
];

function testMaxProductOfConsequtiveNum(tCases) {
  tCases.forEach((tcase, idx) => {
    if (
      tcase.outPut === maxProductOfConsequtiveNum(tcase.inputNumber, tcase.n)
    ) {
      console.log(
        `Testcase passed for ${idx}. The max product for ${tcase.n} consequtive numbers is ${tcase.outPut}`
      );
    } else {
      console.log(
        `Testcase failed for ${idx}. The expected maxproduct is ${
          tcase.outPut
        }. But got ${maxProductOfConsequtiveNum(tcase.inputNumber, tcase.n)}`
      );
    }
  });
}

// testMaxProductOfConsequtiveNum(testCases);
console.log(maxProductOfConsequtiveNum(testCases[0].inputNumber, 2));
